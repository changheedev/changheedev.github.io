---
title: Join 기법 정리 (Nested Loop, Sort Merge, Hash)
categories: [Programming, DB]
tags: [DB, Join]
---

## 1. Nested Loop Join

- NL 조인은 프로그램에서 사용하는 중첩된 반복문과 유사한 방식으로 조인을 수행한다.
- 반복문의 외부에 있는 테이블을 선행 테이블 또는 외부테이블(OUTER TABLE)이라고하고,
- 반복문의 내부에 있는 테이블을 후행 테이블 또는 내부(INNER TABLE)이라고 한다.

```
 FOR 선행 테이블 읽음 -> 외부테이블(OUTER TABLE)
 FOR 후행테이블 읽음 -> 내부 테이블(INNER TABLE)
 (선행 테이블과 후행 테이블조인)
```

- 먼저 선행 테이블의 조건을 만족하는 행을 추출하여 후행 테이블을 읽으면서 조인을 수행한다.
- 선행테이블의 조건을 만족하는 모든 행의 수만큼 반복수행한다.
- 선행 테이블의 조건을 만족하는 행의 수가 많으면 그만큼 후행 테이블 조인작업은 반복 수행된다.
- 결과 행의 수가 적은 테이블을 조인 순서상 선행 테이블로 선택하는것이 전체 일량을 줄일수있다.
- 랜덤 방식으로 데이터 액세스하기 때문에 처리 범위가 좁은 것의 조건으로 선택이 유리하다.

### 드라이빙 테이블(DRIVING TABLE)

조인시 **먼저 액세스되는 쪽을 드라이빙 테이블(DRIVING** **TABLE, OUTER TABLE)**이라고 하며,

나중에 **액세스 되는 테이블을 드리븐 테이블(DRIVEN TABLE, INNER TABLE)**이라고 한다.

**인덱스(INDEX)의 존재 및 우선순위** 혹은 **FROM절에서의 TABLE 지정 순서에 영향**을 받으며

어느 테이블이 먼저 엑세스되느냐에 따라 속도의 차이가 크게 날 수 있으므로 많은 양의 데이터를 다룰 때, 드라이빙 테이블은 매우 중요하다.

#### 결정 규칙

비용기반 옵티마이저(Cost-Based Optimizer, CBO)는 규칙의 우선순위가 아닌 쿼리를 수행하는데 소요되는 예상 비용을 바탕으로 실행계획을 생성한다. 통계정보, DBMS 설정정보, DBMS 버전 등의 차이로 인해 똑같은 SQL문이라도 서로 다른 실행계획이 생성될 수 있다.

**1. 두 컬럼 모두 각각 인덱스가 있는 경우**

- 옵티마이저의 판단으로 각 테이블의 통계 정보에 있는 레코드 건수에 따라 드라이빙 테이블과 드리븐 테이블을 결정한다.

**2. 한쪽의 컬럼에만 인덱스가 있는 경우**

- 드리븐 테이블에 인덱스가 없다면 조인을 하는 과정에서 드라이빙 테이블의 레코드 하나당 드리븐 테이블을 매번 풀 스캔해야만 한다. 따라서 인덱스가 없는 테이블이 드라이빙 테이블로 결정되고 인덱스가 있는 테이블이 드리븐 테이블로 결정된다.

**3. 두 컬럼 모두 인덱스가 없는 경우**

- 어느 테이블을 드라이빙으로 선택하더라도 드리븐 테이블의 풀 스캔은 발생하기 때문에 스캔되는 레코드 수에 따라 옵티마이저가 적절히 드라이빙 테이블을 선택하게 된다.
- 조인이 수행될때 양쪽 테이블의 컬럼에 모두 인덱스가 없을 때만 드리븐 테이블을 풀스캔한다.
- 나머지 경우에는 드라이빙 테이블을 풀 테이블 스캔을 사용할 수는 있어도 드리븐 테이블을 풀 테이블 스캔으로 접근하는 실행 계획은 옵티마이저가 거의 만들어내지 않는다.

### NL Join 동작

![image](https://user-images.githubusercontent.com/17294694/104834022-2022c400-58e0-11eb-9617-018d1bc2ac55.png)

1. 선행 테이블에서 조건을 만족하는 첫 번째 행을 찾음

   - -> 이때 선행 테이블에 주어진 조건을 만족하지 않는 경우 해당 데이터는 필터링됨

2. 선행 테이블의 조인 키를 가지고 후행 테이블에 조인 키가 존재하는지 찾음

   - -> 조인시도

3. 후행 테이블의 인덱스에 선행 테이블의 조인 키가 존재하는지 확인

   - -> 선행 테이블의 조인 값이 후행 테이블에 존재하지 않으면 선행 테이블 데이터는 필터링됨(조인작업x)

4. 인덱스에서 추출한 레코드 식별자를 이용하여 테이블을 액세스

   - -> 인덱스 스캔을 통한 테이블 액세스

5. ~ 11) 반복수행

## 2. Sort Merge Join

- 조인 컬럼을 기준으로 데이터를 정렬하여 조인을 수행.
- 주로 스캔 방식으로 데이터를 읽는다.
- 랜덤 액세스로 부담이 되는 넓은 범위의 데이터를 처리 할 때 이용.
- 정렬할 데이터가 많아 메모리에 모든 정렬 작업을 수행하기 어려운 경우에는 임시영역을 사용하므로 성능이 떨어질 수 있다.
- Hash Join과는 달리 동등 조인 뿐만 아니라 비동등 조인에 대해서 조인 작업이 가능하다.
- 조인 컬럼의 인덱스가 존재하지 않을 경우에도 사용할 수 있는 기법이다.
- 조인 작업을 위해 항상 정렬 작업이 발생하는 것은 아니다.

### Sort Merge Join 동작

![image](https://user-images.githubusercontent.com/17294694/104834026-244ee180-58e0-11eb-9af6-d3c4d1d347e3.png)

1. 선행 테이블에서 주어진 조건을 만족하는 행을 찾음

2. 선행 테이블의 조인 키를 기준으로 정렬 작업을 수행

   - 1 ~ 2번작업을 선행 테이블의 조건을 만족하는 모든 행에 대해 반복 수행

3. 후행 테이블에서 주어진 조건을 만족하는 행을 찾음

4. 후행 테이블의 조인 키를 기준으로 정렬 작업을 수행

   - 3 ~ 4번 작업을 후행 테이블의 조건을 만족하는 모든 행에 대해 반복 수행

5. 정렬된 결과를 이용하여 조인을 수행하며 조인에 성공하면 추출버퍼에 넣음

## 3. Hash Join

- 조인 컬럼을 기준으로 해쉬함수를 수행하여 서로 동일한 해쉬 값을 갖는 것들 사이에서 실제 값이 같은지를 비교하면서 조인을 수행
- NL Join 랜덤액세스 와 Sort Merge Join 의 문제점인 정렬 작업의 부담을 해결하기 위한 대안으로 등장
- 조인 컬럼의 인덱스가 존재하지 않을 경우에도 사용할 수 있는 기법이다.
- 해쉬 함수를 이용하여 조인을 수행하기 때문에 동등 조건에만 사용 할 수 있다.
- Hash Join 작업을 수행하기위해 해쉬 테이블을 메모리에 생성해야한다.
  - 메모리에 적재할 수 있는 영역에 크기보다 커지면 임시 영역(디스크)에 해쉬 테이블을 저장한다.
- Hash Join을 할 때는 결과 행의 수가 적은 테이블을 선행 테이블로 사용하는 것이 좋다.

### Hash Join 동작

![image](https://user-images.githubusercontent.com/17294694/104834030-27e26880-58e0-11eb-8d68-937559cf6244.png)

1. 선행 테이블에서 주어진 조건을 만족하는 행을 찾음
2. 선행 테이블의 조인 키를 기준으로 해쉬 함수를 적용하여 해쉬 테이블을 생성

   - 조인 컬럼과 SELECT 절에서 필요로 하는 컬럼도 함께 저장
   - 1 ~ 2번 작업을 선행 테이블의 조건을 만족하는 모든 행에 대해 반복수행

3. 후행 테이블에서 주어진 조건을 만족하는 행을 찾음
4. 후행 테이블의 조인 키를 기준으로 해쉬 함수를 적용하여 해당 버킷을 찾음

   - 조인 키를 이용해서 실제 조인될 데이터를 찾음

5. 조인에 성공하면 추출버퍼에 넣음

   - 3 ~ 5번 작업을 후행 테이블의 조건을 만족하는 모든 행에 대해서 반복수행

## 참고자료

- [http://www.gurubee.net/lecture/2388](http://www.gurubee.net/lecture/2388)
- [https://devuna.tistory.com/36](https://devuna.tistory.com/36)
